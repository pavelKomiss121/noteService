# Проект: Работа с Типами, Строками, Областями Видимости и Конвертацией Температур

Этот проект содержит набор заданий на Java, предназначенных для изучения базовых понятий:
примитивные типы данных, строковые операции, области видимости переменных, константы и конвертация
температур между разными шкалами.

## Структура проекта

### 1. TypeCalculator.java

Пример выполнения операций между переменными разных числовых типов и демонстрация автоматического
приведения типов.

### 2. StringOperations.java

Работа со строками и символами:

- Конкатенация
- Преобразование символов и чисел в строки и обратно
- Извлечение символов из строки

### 3. ConstantsAndScope.java

Показано:

- Использование `final` и `static final` констант
- Разные области видимости переменных
- Ошибки компиляции при попытке выхода за границы области видимости

### 4. TemperatureConverter.java

Конвертер температур между шкалами:

- Цельсий ↔ Фаренгейт
- Цельсий ↔ Кельвин

---

## Дополнительный модуль: Условные операторы и юнит-тестирование (MP-23)

### TrafficLight.java

Симуляция работы светофора с использованием строк и условных операторов. Юнит-тесты проверяют
корректность ответов в зависимости от сигнала.

### WeekdayDeterminer.java

Определяет тип дня недели по номеру (рабочий/выходной), возвращая описание с дополнительной
информацией. Юнит-тесты охватывают рабочие и граничные случаи.

### TaxCalculator.java

Программа для расчета налога по прогрессивной шкале. Обрабатываются разные диапазоны доходов и
рассчитывается эффективная ставка налогообложения.

### TheaterTickets.java

Расчет стоимости билета в театр с учётом возраста, наличия студенческого билета и выходного дня.
Поддерживаются комбинированные скидки. Тесты проверяют граничные и типичные случаи.

### LogicalTrainer.java

Логический тренажер, который оценивает логические выражения на основе пользовательских
предпочтений (любовь к программированию, математике, чтению).

Каждый модуль сопровождается юнит-тестами, написанными с использованием библиотеки AssertJ.

___

## Сравнение с ArrayList (MP-54)

### Различия в реализации методов для `LinkedList` vs `ArrayList`

При работе с `LinkedList`:

- Используются **итераторы** для безопасного удаления элементов (`iterator.remove()`), особенно в
  методах типа `removeDuplicates`.
- Методы реализованы с упором на **последовательный доступ**, а не по индексу — в отличие от
  `ArrayList`, где эффективнее использовать `get(i)`.

Для `ArrayList`:

- Методы могли бы использовать **прямой доступ по индексу** (
  `for (int i = 0; i < list.size(); i++)`) для максимальной производительности.
- Удаление элементов выполняется менее эффективно, так как требует сдвига всех последующих
  элементов.

---

### Особенности `LinkedList`, использованные для оптимизации

- **Итерация и удаление**: благодаря двусвязной структуре, метод `iterator.remove()` работает за O(
  1), без необходимости сдвига элементов.
- **Работа с головой/хвостом списка**: операции `addFirst()`, `addLast()`, `removeFirst()` и
  `removeLast()` очень эффективны — за O(1).
- Использование **`ListIterator`** позволяет перемещаться в обе стороны, что полезно при реализации,
  например, `reverse()`.

---

### Методы, которые работают эффективнее:

| Метод / Операция     | LinkedList                | ArrayList                   |
|----------------------|---------------------------|-----------------------------|
| Вставка в начало     | ✅ O(1) — очень эффективно | ❌ O(n) — требуется сдвиг    |
| Вставка в конец      | ✅ O(1)                    | ✅ O(1) амортизированное     |
| Удаление по значению | ✅ O(1) с итератором       | ❌ O(n) — + сдвиг элементов  |
| Поиск по индексу     | ❌ O(n) — требуется проход | ✅ O(1) — прямой доступ      |
| Повторный проход     | Лучше с итератором        | ✅ Быстрый доступ по индексу |

---

### Различия в подходе к обработке элементов

- В `LinkedList` важно использовать **итераторы** при изменении списка во время обхода — иначе
  возникает `ConcurrentModificationException`.
- В `ArrayList` предпочтительно использовать **индексацию**, особенно если список не изменяется в
  процессе обхода.
- Методы, завязанные на удаление, **гораздо безопаснее и производительнее в `LinkedList`**, если
  использовать `Iterator`.

# Тестирование NoteService и Note

## Что тестировал

- В `NoteService` проверил добавление, получение, обновление, удаление заметок, а также поиск по
  тексту и тегам.
- В `Note` проверил конструктор, сеттеры, работу с тегами, equals/hashCode.

## Какие тесты были

- Позитивные (например, успешное добавление и поиск).
- Негативные (null title, пустой тег, несуществующий id).
- Граничные (пустые коллекции, текст null → превращается в `""`, регистр в тегах и тексте).

## Почему именно такие

Хотел убедиться, что сервис корректно работает и с нормальными данными, и с ошибочными входами.  
Границы (null, пустые строки, большие id) я проверил, потому что обычно именно там чаще всего
всплывают баги.

## Что оказалось важным

- Проверка того, что `getTags()` возвращает немодифицируемый сет.
- Нормализация тегов в нижний регистр.
- `Optional` в `getNoteById` вместо `null`.
- Поведение поиска: по подстроке, без учёта регистра.

## Покрытие

Сначала было:

- NoteService ~96% методов / 91% ветвей
- Note ~62% методов / 40% ветвей

После того как дописал все тесты:

- **100% методов и ветвей** для обоих классов.

## Вывод

Полное покрытие тестами помогло найти пару ошибок (например, работа с Optional и нормализация
текста/tags). В итоге код стал надёжнее.

